<!doctype html>
<html lang="zh-Hans">
  <head>
    <title>docker使用 // ZechariahZheng&#39;s Blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.86.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="ZechariahZheng" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://ZechariahZheng.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="docker使用"/>
<meta name="twitter:description" content="运行交互式的容器 $ docker run -it ubuntu /bin/bash 各个参数解析：
  -t: 在新容器内指定一个伪终端或终端。
  -i: 允许你对容器内的标准输入 (STDIN) 进行交互。
  需要确认容器有在运行，可以通过 docker ps 来查看： 在容器内使用 docker logs 命令，查看容器内的标准输出： 下面的命令来停止: $ docker stop &lt;容器id&gt; #停止的容器可以通过 docker restart 重启： $ docker restart &lt;容器 ID&gt; 后台运行 在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式。
$ docker run -itd --name ubuntu-test ubuntu /bin/bash exec 命令 下面演示了使用 docker exec 命令。
docker exec -it 243c32535da7 /bin/bash 注意： 如果从这个容器退出，不会导致容器的停止，这就是为什么推荐大家使用 docker exec 的原因。"/>

    <meta property="og:title" content="docker使用" />
<meta property="og:description" content="运行交互式的容器 $ docker run -it ubuntu /bin/bash 各个参数解析：
  -t: 在新容器内指定一个伪终端或终端。
  -i: 允许你对容器内的标准输入 (STDIN) 进行交互。
  需要确认容器有在运行，可以通过 docker ps 来查看： 在容器内使用 docker logs 命令，查看容器内的标准输出： 下面的命令来停止: $ docker stop &lt;容器id&gt; #停止的容器可以通过 docker restart 重启： $ docker restart &lt;容器 ID&gt; 后台运行 在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式。
$ docker run -itd --name ubuntu-test ubuntu /bin/bash exec 命令 下面演示了使用 docker exec 命令。
docker exec -it 243c32535da7 /bin/bash 注意： 如果从这个容器退出，不会导致容器的停止，这就是为什么推荐大家使用 docker exec 的原因。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ZechariahZheng.github.io/posts/docker%E4%BD%BF%E7%94%A8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-19T20:28:25+08:00" />
<meta property="article:modified_time" content="2021-07-19T20:28:25+08:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://ZechariahZheng.github.io/"><img class="app-header-avatar" src="/images/1.jpg" alt="ZechariahZheng" /></a>
      <h1>ZechariahZheng&#39;s Blog</h1>
      <p>吾魂兮无求乎永生，竭尽兮人事之所能</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/ZechariahZheng" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">docker使用</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 19, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h4 id="运行交互式的容器">运行交互式的容器</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ docker run -it ubuntu /bin/bash
</code></pre></div><p>各个参数解析：</p>
<ul>
<li>
<p><strong>-t:</strong> 在新容器内指定一个伪终端或终端。</p>
</li>
<li>
<p><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互。</p>
</li>
</ul>
<h4 id="需要确认容器有在运行可以通过-docker-ps-来查看">需要确认容器有在运行，可以通过 docker ps 来查看：</h4>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719200501348.png" alt="image-20210719200501348"></p>
<h4 id="在容器内使用-docker-logs-命令查看容器内的标准输出">在容器内使用 docker logs 命令，查看容器内的标准输出：</h4>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719200534290.png" alt="image-20210719200534290"></p>
<h4 id="下面的命令来停止">下面的命令来停止:</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ docker stop &lt;容器id&gt;

<span style="color:#75715e">#停止的容器可以通过 docker restart 重启：</span>
$ docker restart &lt;容器 ID&gt;
</code></pre></div><h4 id="后台运行">后台运行</h4>
<p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ docker run -itd --name ubuntu-test ubuntu /bin/bash
</code></pre></div><h4 id="exec-命令">exec 命令</h4>
<p>下面演示了使用 docker exec 命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SHELL" data-lang="SHELL">docker exec -it 243c32535da7 /bin/bash
</code></pre></div><p><strong>注意：</strong> 如果从这个容器退出，不会导致容器的停止，这就是为什么推荐大家使用 docker exec 的原因。</p>
<p>更多参数说明请使用 docker exec &ndash;help 命令查看。</p>
<p>但是docker run，从这个容器中退出，会导致容器的停止</p>
<h4 id="导出容器">导出容器</h4>
<p>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ docker export 1e560fca3906 &gt; ubuntu.tar
</code></pre></div><h4 id="导入容器快照">导入容器快照</h4>
<p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SHELL" data-lang="SHELL">$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1
</code></pre></div><h4 id="删除容器">删除容器</h4>
<p>删除容器使用 <strong>docker rm</strong> 命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SHELL" data-lang="SHELL">$ docker rm -f 1e560fca3906
</code></pre></div><p>我们也可以通过 -p 参数来设置不一样的端口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-SHELL" data-lang="SHELL">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py
</code></pre></div><h4 id="网络端口的快捷方式">网络端口的快捷方式</h4>
<p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射，<strong>docker</strong> 还提供了另一个快捷方式 <strong>docker port</strong>，使用 <strong>docker port</strong> 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p>
<p>上面我们创建的 web 应用容器 ID 为 <strong>bf08b7f2cd89</strong> 名字为 <strong>wizardly_chandrasekhar</strong>。</p>
<p>我可以使用 <strong>docker port bf08b7f2cd89</strong> 或 <strong>docker port wizardly_chandrasekhar</strong> 来查看容器端口的映射情况。</p>
<h4 id="查看web应用程序容器的进程">查看WEB应用程序容器的进程</h4>
<p>我们还可以使用 docker top 来查看容器内部运行的进程</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201304089.png" alt="image-20210719201304089"></p>
<h4 id="列出镜像列表常用">列出镜像列表(常用)</h4>
<p>使用 <strong>docker images</strong> 来列出本地主机上的镜像。</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201340746.png" alt="image-20210719201340746"></p>
<h4 id="获取一个新的镜像">获取一个新的镜像</h4>
<p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201408662.png" alt="image-20210719201408662"></p>
<h4 id="删除镜像">删除镜像</h4>
<p>镜像删除使用 <strong>docker rmi</strong> 命令，比如我们删除 hello-world 镜像：</p>
<p>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</p>
<ul>
<li>
<p>1、从已经创建的容器中更新镜像，并且提交这个镜像</p>
</li>
<li>
<p>2、使用 Dockerfile 指令来创建一个新的镜像</p>
</li>
</ul>
<h4 id="更新镜像">更新镜像</h4>
<p>更新镜像之前，我们需要使用镜像来创建一个容器。</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201514740.png" alt="image-20210719201514740"></p>
<p>在运行的容器内使用 <strong>apt-get update</strong> 命令进行更新。</p>
<p>在完成操作之后，输入 exit 命令来退出这个容器。</p>
<p>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201539839.png" alt="image-20210719201539839"></p>
<h4 id="构建镜像">构建镜像</h4>
<p>我们使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201608264.png" alt="image-20210719201608264"></p>
<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p>
<p>第一条FROM，指定使用哪个镜像源</p>
<p>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</p>
<p>然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201643184.png" alt="image-20210719201643184"></p>
<h4 id="设置镜像标签">设置镜像标签</h4>
<p>我们可以使用 docker tag 命令，为镜像添加一个新的标签。</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201708005.png" alt="image-20210719201708005"></p>
<p>docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。</p>
<p>使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。</p>
<h4 id="网络端口映射">网络端口映射</h4>
<p>我们也可以使用 <strong>-p</strong> 标识来指定容器端口绑定到主机端口。</p>
<p>两种方式的区别是:</p>
<ul>
<li><strong>-P :<strong>是容器内部端口</strong>随机</strong>映射到主机的高端口。</li>
<li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li>
</ul>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201749688.png" alt="image-20210719201749688"></p>
<p>另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201831646.png" alt="image-20210719201831646"></p>
<p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <strong>/udp</strong>。</p>
<p><img src="https://gitee.com/ZechariahZheng/pic-go/raw/master/image-20210719201855193.png" alt="image-20210719201855193"></p>
<h4 id="查看容器ip地址">查看容器ip地址</h4>
<p>docker inspect &lt;容器名&gt;</p>
<h4 id="查看容器网络">查看容器网络</h4>
<p>使用docker-compose up启动容器后，这些容器都会被加入app_default网络中。使用docker network ls可以查看网络列表，docker network inspect <!-- raw HTML omitted -->可以查看对应网络的配置。</p>
<h2 id="容器网络的基本">容器网络的基本</h2>
<p>创建一个docker容器，docker系统会自动为该容器分配一个ip地址，通常是172.17开头。</p>
<p>我们可以在主机上用 docker inspect 命令 或者进入容器用ifconfig命令来查看容器的ip地址。</p>
<p>假设某个容器(假设容器的名称为myweb)被分配的地址是 172.17.0.2，该容器上启动了一个web服务，其端口号是80（注意这是容器中的端口号）。</p>
<p>这时我们用docker port命令可以查看该web服务在容器的端口对应到主机端口的信息，如：</p>
<p>docker port myweb</p>
<p>输出</p>
<p>80/tcp -&gt; 0.0.0.0:32776</p>
<p><strong>总结下，如果某个容器提供了对外的服务（如web服务），则统一的访问方式可以利用docker主机的ip地址和容器映射到主机上的端口来统一访问。</strong></p>
<p><strong>dockerfile示例：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">    <span style="color:#ae81ff">1</span> FROM centos:centos6
    <span style="color:#ae81ff">2</span> MAINTAINER David <span style="color:#e6db74">&#34;xx@xx.com&#34;</span>
    <span style="color:#ae81ff">3</span> RUN yum install -y mysql-server mysql
    <span style="color:#ae81ff">4</span> RUN /etc/init.d/mysqld start
    <span style="color:#ae81ff">5</span> RUN mysql -e <span style="color:#e6db74">&#34;grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;1234&#39;;&#34;</span>
    <span style="color:#ae81ff">6</span> RUN mysql -e <span style="color:#e6db74">&#34;grant all privileges on *.* to &#39;root&#39;@&#39;localhost&#39; identified by &#39;1234&#39;;&#34;</span>
    <span style="color:#ae81ff">7</span> EXPOSE <span style="color:#ae81ff">3306</span>
    <span style="color:#ae81ff">8</span> CMD <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/usr/bin/mysqld&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><h4 id="树莓派中使用的java镜像">树莓派中使用的java镜像</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker pull armhfbuild/java
</code></pre></div><h4 id="将容器保存为镜像">将容器保存为镜像</h4>
<p>docker commit [选项] [容器ID或容器名] [仓库名:标签]</p>
<p>例子：</p>
<p># docker commit -a &lsquo;weikaixxxxxx&rsquo; -m &lsquo;导入了数据库&rsquo; 9adeb5943045 mysql:v2</p>
<p><strong>docker commit e400eca4994d centos1</strong></p>
<h4 id="进入容器">进入容器</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker exec -it 243c32535da7 /bin/bash
</code></pre></div><h4 id="docker容器向宿主机传送文件"><strong>Docker容器向宿主机传送文件</strong></h4>
<p>格式:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker cp container_id:&lt;docker容器内的路径&gt; &lt;本地保存文件的路径&gt;
</code></pre></div><p>比如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">docker cp 10704c9eb7bb:/root/test.text /home/vagrant/test.txt
</code></pre></div><h4 id="宿主机向docker容器传送文件"><strong>宿主机向Docker容器传送文件</strong></h4>
<p>格式:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker cp 本地文件的路径 container_id:&lt;docker容器内的路径&gt;
</code></pre></div><p>比如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker cp /home/vagrant/test.txt 10704c9eb7bb:/root/test.text
</code></pre></div><h4 id="使用dockerfile文件构建镜像">使用Dockerfile文件构建镜像：</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker build -t xxxx:xxxx  .
</code></pre></div>
    </div>
    <div class="post-footer">
      
      
      
<section>
<script src="https://utteranc.es/client.js"
        repo="ZechariahZheng/hugoblogtalks"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</section>

    </div>
  </article>

    </main>
  </body>
</html>
